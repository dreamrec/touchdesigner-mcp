"""
TouchDesigner MCP — Automated Project Setup
=============================================
Run this script inside TouchDesigner's Textport (Dialogs > Textport)
or via a Script DAT to automatically create the entire MCP WebServer
component with all 28 API handlers.

Usage:
  1. Open TouchDesigner 2025
  2. Open Textport: Dialogs > Textport and DATs
  3. Paste this entire script and press Enter
  4. Done — the MCP server is running on port 9981

What it creates:
  /project1/mcp_server          (Base COMP — the container)
  /project1/mcp_server/webserver (Web Server DAT — port 9981)
  /project1/mcp_server/callbacks (Text DAT — all 28 API handlers)
  /project1/mcp_server/info      (Text DAT — status/version info)

It will skip creation if /project1/mcp_server already exists.
"""

# ═══════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════

MCP_PORT = 9981
COMP_NAME = 'mcp_server'
PARENT_PATH = '/project1'

# ═══════════════════════════════════════════════════════════════
# Callbacks source code (embedded)
# ═══════════════════════════════════════════════════════════════

CALLBACKS_CODE = r'''"""
TouchDesigner MCP WebServer DAT Callbacks
==========================================
Auto-generated by setup_mcp_in_td.py
28 API handlers for full MCP server functionality.
Compatible with TouchDesigner 2025.30000+
"""

import json
import traceback
import sys
import os
import base64
import time

# ─────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────

API_VERSION = "1.0.0"
SCREENSHOT_TEMP_PATH = "/tmp/td_mcp_screenshot.png"

# ─────────────────────────────────────────────────────────────
# Main HTTP Router
# ─────────────────────────────────────────────────────────────

def onHTTPRequest(webServerDAT, request, response):
    uri = request.get('uri', '/')
    method = request.get('method', 'GET')

    body = {}
    raw_data = request.get('data', None)
    if raw_data:
        try:
            if isinstance(raw_data, bytes):
                body = json.loads(raw_data.decode('utf-8'))
            elif isinstance(raw_data, str):
                body = json.loads(raw_data)
        except (json.JSONDecodeError, UnicodeDecodeError):
            body = {}

    response['Access-Control-Allow-Origin'] = '*'
    response['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'
    response['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

    if method == 'OPTIONS':
        response['statusCode'] = 204
        response['statusReason'] = 'No Content'
        response['data'] = ''
        return response

    try:
        routes = {
            '/api/health':              handle_health,
            '/api/info':                handle_info,
            '/api/nodes':               handle_get_nodes,
            '/api/node/detail':         handle_get_node_detail,
            '/api/node/params':         handle_get_params,
            '/api/node/params/set':     handle_set_params,
            '/api/node/create':         handle_create_node,
            '/api/node/delete':         handle_delete_node,
            '/api/node/connect':        handle_connect_nodes,
            '/api/node/disconnect':     handle_disconnect_nodes,
            '/api/node/connections':    handle_get_connections,
            '/api/node/errors':         handle_get_errors,
            '/api/node/content':        handle_get_content,
            '/api/node/content/set':    handle_set_content,
            '/api/node/copy':           handle_copy_node,
            '/api/node/rename':         handle_rename_node,
            '/api/exec':                handle_exec_python,
            '/api/screenshot':          handle_screenshot,
            '/api/chop/data':           handle_chop_data,
            '/api/sop/data':            handle_sop_data,
            '/api/cooking':             handle_cooking_info,
            '/api/search':              handle_search_nodes,
            '/api/families':            handle_list_families,
            '/api/python/help':         handle_python_help,
            '/api/python/classes':      handle_python_classes,
            '/api/timeline':            handle_timeline,
            '/api/timeline/set':        handle_timeline_set,
            '/api/pulse':               handle_pulse_param,
        }

        handler = routes.get(uri)
        if handler:
            result = handler(body)
        else:
            result = {'error': f'Unknown endpoint: {uri}', 'available': list(routes.keys())}
            response['statusCode'] = 404
            response['statusReason'] = 'Not Found'
            _send_json(response, result)
            return response

        response['statusCode'] = 200
        response['statusReason'] = 'OK'
        _send_json(response, result)

    except Exception as e:
        error_result = {
            'error': str(e),
            'type': type(e).__name__,
            'traceback': traceback.format_exc()
        }
        response['statusCode'] = 500
        response['statusReason'] = 'Internal Server Error'
        _send_json(response, error_result)

    return response


def _send_json(response, data):
    response['data'] = json.dumps(data, default=str).encode('utf-8')
    response['content-type'] = 'application/json'


def _serialize_op(node, include_params=False):
    info = {
        'name': node.name,
        'path': node.path,
        'type': node.type,
        'family': node.family,
        'label': getattr(node, 'label', ''),
        'nodeX': node.nodeX,
        'nodeY': node.nodeY,
        'isCOMP': node.isCOMP,
        'isTOP': node.isTOP,
        'isCHOP': node.isCHOP,
        'isSOP': node.isSOP,
        'isDAT': node.isDAT,
        'isMAT': node.isMAT,
        'bypass': node.bypass,
        'lock': node.lock,
        'display': node.display if hasattr(node, 'display') else False,
        'render': node.render if hasattr(node, 'render') else False,
        'errors': node.errors(recurse=False) if hasattr(node, 'errors') else '',
        'warnings': node.warnings(recurse=False) if hasattr(node, 'warnings') else '',
    }
    if include_params:
        info['parameters'] = _serialize_params(node)
    return info


def _serialize_params(node):
    params = {}
    for p in node.pars():
        try:
            params[p.name] = {
                'value': p.eval(),
                'default': p.default,
                'label': p.label,
                'page': p.page.name if p.page else '',
                'style': p.style,
                'min': p.min if hasattr(p, 'min') else None,
                'max': p.max if hasattr(p, 'max') else None,
                'readOnly': p.readOnly,
                'isPulse': p.isPulse,
                'isMomentary': p.isMomentary,
                'isToggle': p.isToggle,
                'isMenu': p.isMenu,
                'menuNames': list(p.menuNames) if p.isMenu else [],
                'menuLabels': list(p.menuLabels) if p.isMenu else [],
            }
        except Exception:
            params[p.name] = {'value': str(p), 'error': 'Could not fully serialize'}
    return params


# ─────────────────────────────────────────────────────────────
# Handlers
# ─────────────────────────────────────────────────────────────

def handle_health(body):
    return {
        'status': 'ok',
        'api_version': API_VERSION,
        'timestamp': time.time(),
    }


def handle_info(body):
    return {
        'version': app.version,
        'build': app.build,
        'osName': app.osName,
        'osVersion': app.osVersion,
        'product': app.product,
        'launchDir': app.launchDir,
        'project_name': project.name,
        'project_folder': project.folder,
        'fps': project.cookRate,
        'realTime': project.realTime,
        'frame': absTime.frame,
        'seconds': absTime.seconds,
        'timeline_start': project.cookRange[0] if hasattr(project, 'cookRange') else 1,
        'timeline_end': project.cookRange[1] if hasattr(project, 'cookRange') else 600,
        'api_version': API_VERSION,
    }


def handle_get_nodes(body):
    path = body.get('path', '/')
    family_filter = body.get('family', None)
    type_filter = body.get('type', None)
    include_params = body.get('include_params', False)
    limit = body.get('limit', 100)
    offset = body.get('offset', 0)

    target = op(path)
    if target is None:
        return {'error': f'Node not found: {path}'}
    if not target.isCOMP:
        return {'error': f'Node is not a COMP (cannot have children): {path}', 'node_type': target.type}

    children = target.children
    if family_filter:
        family_filter = family_filter.upper()
        children = [c for c in children if c.family == family_filter]
    if type_filter:
        children = [c for c in children if c.type == type_filter]

    total = len(children)
    children = children[offset:offset + limit]
    nodes = [_serialize_op(c, include_params=include_params) for c in children]

    return {
        'path': path, 'total': total, 'count': len(nodes),
        'offset': offset, 'has_more': total > offset + len(nodes), 'nodes': nodes,
    }


def handle_get_node_detail(body):
    path = body.get('path')
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}

    detail = _serialize_op(node, include_params=True)
    detail['inputs'] = []
    for conn in node.inputConnectors:
        for c in conn.connections:
            detail['inputs'].append({'from': c.owner.path, 'from_index': c.index, 'to_index': conn.index})
    detail['outputs'] = []
    for conn in node.outputConnectors:
        for c in conn.connections:
            detail['outputs'].append({'to': c.owner.path, 'to_index': c.index, 'from_index': conn.index})
    if node.isCOMP:
        detail['children_count'] = len(node.children)
        detail['child_names'] = [c.name for c in node.children[:50]]
    return detail


def handle_get_params(body):
    path = body.get('path')
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}

    page_filter = body.get('page', None)
    name_filter = body.get('names', None)
    params = {}
    for p in node.pars():
        if page_filter and p.page and p.page.name != page_filter:
            continue
        if name_filter and p.name not in name_filter:
            continue
        try:
            params[p.name] = {
                'value': p.eval(), 'default': p.default, 'label': p.label,
                'page': p.page.name if p.page else '', 'style': p.style,
                'readOnly': p.readOnly, 'isPulse': p.isPulse, 'isMenu': p.isMenu,
                'menuNames': list(p.menuNames) if p.isMenu else [],
            }
        except Exception:
            params[p.name] = {'value': str(p), 'error': 'Could not serialize'}
    return {'path': path, 'type': node.type, 'parameters': params}


def handle_set_params(body):
    path = body.get('path')
    params = body.get('params', {})
    if not path:
        return {'error': 'Missing required field: path'}
    if not params:
        return {'error': 'Missing required field: params'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}

    results = {}
    for name, value in params.items():
        try:
            p = getattr(node.par, name, None)
            if p is None:
                results[name] = {'success': False, 'error': f'Parameter not found: {name}'}
                continue
            if p.readOnly:
                results[name] = {'success': False, 'error': f'Parameter is read-only: {name}'}
                continue
            p.val = value
            results[name] = {'success': True, 'new_value': p.eval()}
        except Exception as e:
            results[name] = {'success': False, 'error': str(e)}
    return {'path': path, 'results': results}


def handle_create_node(body):
    parent_path = body.get('parent_path', '/')
    node_type = body.get('node_type')
    name = body.get('name', None)
    if not node_type:
        return {'error': 'Missing required field: node_type'}
    parent_node = op(parent_path)
    if parent_node is None:
        return {'error': f'Parent node not found: {parent_path}'}
    if not parent_node.isCOMP:
        return {'error': f'Parent is not a COMP: {parent_path}'}
    try:
        new_node = parent_node.create(node_type, name)
        return {'success': True, 'node': _serialize_op(new_node)}
    except Exception as e:
        return {'error': f'Failed to create node: {str(e)}', 'node_type': node_type}


def handle_delete_node(body):
    path = body.get('path')
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    node_info = {'name': node.name, 'path': node.path, 'type': node.type}
    try:
        node.destroy()
        return {'success': True, 'deleted': node_info}
    except Exception as e:
        return {'error': f'Failed to delete node: {str(e)}'}


def handle_connect_nodes(body):
    source_path = body.get('source_path')
    target_path = body.get('target_path')
    source_index = body.get('source_index', 0)
    target_index = body.get('target_index', 0)
    if not source_path or not target_path:
        return {'error': 'Missing required fields: source_path and target_path'}
    source = op(source_path)
    target = op(target_path)
    if source is None:
        return {'error': f'Source node not found: {source_path}'}
    if target is None:
        return {'error': f'Target node not found: {target_path}'}
    try:
        source.outputConnectors[source_index].connect(target.inputConnectors[target_index])
        return {'success': True, 'connection': {
            'source': source.path, 'source_index': source_index,
            'target': target.path, 'target_index': target_index,
        }}
    except Exception as e:
        return {'error': f'Failed to connect: {str(e)}'}


def handle_disconnect_nodes(body):
    path = body.get('path')
    connector_type = body.get('connector_type', 'input')
    index = body.get('index', 0)
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    try:
        if connector_type == 'input':
            node.inputConnectors[index].disconnect()
        else:
            node.outputConnectors[index].disconnect()
        return {'success': True, 'path': path, 'connector_type': connector_type, 'index': index}
    except Exception as e:
        return {'error': f'Failed to disconnect: {str(e)}'}


def handle_get_connections(body):
    path = body.get('path')
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    inputs = []
    for conn in node.inputConnectors:
        for c in conn.connections:
            inputs.append({'from_path': c.owner.path, 'from_index': c.index, 'to_index': conn.index})
    outputs = []
    for conn in node.outputConnectors:
        for c in conn.connections:
            outputs.append({'to_path': c.owner.path, 'to_index': c.index, 'from_index': conn.index})
    return {'path': path, 'inputs': inputs, 'outputs': outputs}


def handle_get_errors(body):
    path = body.get('path', '/')
    recurse = body.get('recurse', True)
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    results = []
    def collect_errors(n):
        errs = n.errors(recurse=False) if hasattr(n, 'errors') else ''
        warns = n.warnings(recurse=False) if hasattr(n, 'warnings') else ''
        if errs or warns:
            results.append({'path': n.path, 'name': n.name, 'type': n.type, 'errors': errs, 'warnings': warns})
        if recurse and n.isCOMP:
            for child in n.children:
                collect_errors(child)
    collect_errors(node)
    return {'path': path, 'recurse': recurse, 'count': len(results), 'issues': results}


def handle_get_content(body):
    path = body.get('path')
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    if not node.isDAT:
        return {'error': f'Node is not a DAT: {path} (type: {node.type})'}
    try:
        if hasattr(node, 'numRows') and node.numRows > 0:
            rows = []
            for r in range(node.numRows):
                row = []
                for c in range(node.numCols):
                    row.append(node[r, c].val)
                rows.append(row)
            return {'path': path, 'format': 'table', 'numRows': node.numRows, 'numCols': node.numCols, 'data': rows}
        else:
            return {'path': path, 'format': 'text', 'text': node.text}
    except Exception:
        return {'path': path, 'format': 'text', 'text': node.text if hasattr(node, 'text') else ''}


def handle_set_content(body):
    path = body.get('path')
    text = body.get('text', None)
    table = body.get('table', None)
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    if not node.isDAT:
        return {'error': f'Node is not a DAT: {path}'}
    try:
        if text is not None:
            node.text = text
            return {'success': True, 'path': path, 'format': 'text', 'length': len(text)}
        elif table is not None:
            node.clear()
            for r, row in enumerate(table):
                for c, val in enumerate(row):
                    node[r, c] = val
            return {'success': True, 'path': path, 'format': 'table', 'rows': len(table)}
        else:
            return {'error': 'Provide either "text" or "table" field'}
    except Exception as e:
        return {'error': f'Failed to set content: {str(e)}'}


def handle_copy_node(body):
    source_path = body.get('source_path')
    dest_parent = body.get('dest_parent', None)
    new_name = body.get('new_name', None)
    if not source_path:
        return {'error': 'Missing required field: source_path'}
    source = op(source_path)
    if source is None:
        return {'error': f'Source node not found: {source_path}'}
    parent_node = op(dest_parent) if dest_parent else source.parent()
    if parent_node is None:
        return {'error': f'Destination parent not found: {dest_parent}'}
    try:
        new_node = parent_node.copy(source, name=new_name)
        return {'success': True, 'node': _serialize_op(new_node)}
    except Exception as e:
        return {'error': f'Failed to copy node: {str(e)}'}


def handle_rename_node(body):
    path = body.get('path')
    new_name = body.get('new_name')
    if not path or not new_name:
        return {'error': 'Missing required fields: path and new_name'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    old_name = node.name
    try:
        node.name = new_name
        return {'success': True, 'old_name': old_name, 'new_name': node.name, 'new_path': node.path}
    except Exception as e:
        return {'error': f'Failed to rename: {str(e)}'}


def handle_exec_python(body):
    code = body.get('code')
    if not code:
        return {'error': 'Missing required field: code'}
    import io
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    captured_out = io.StringIO()
    captured_err = io.StringIO()
    result_value = None
    try:
        sys.stdout = captured_out
        sys.stderr = captured_err
        try:
            exec_globals = {'op': op, 'ops': ops, 'project': project, 'app': app,
                          'absTime': absTime, 'me': me, 'parent': parent, 'mod': mod,
                          'ui': ui, 'tdu': tdu}
            exec(code, exec_globals)
            result_value = exec_globals.get('__result__', None)
        except SyntaxError:
            result_value = eval(code)
    except Exception as e:
        sys.stdout = old_stdout
        sys.stderr = old_stderr
        return {'error': str(e), 'type': type(e).__name__, 'traceback': traceback.format_exc(),
                'stdout': captured_out.getvalue(), 'stderr': captured_err.getvalue()}
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr
    return {'success': True, 'result': str(result_value) if result_value is not None else None,
            'stdout': captured_out.getvalue(), 'stderr': captured_err.getvalue()}


def handle_screenshot(body):
    path = body.get('path', None)
    try:
        if path:
            target = op(path)
            if target is None:
                return {'error': f'Node not found: {path}'}
            if not target.isTOP:
                return {'error': f'Node is not a TOP: {path} (type: {target.type})'}
        else:
            return {'error': 'Provide path to a TOP node to screenshot'}
        img_bytes = target.saveByteArray('.png')
        img_b64 = base64.b64encode(bytes(img_bytes)).decode('ascii')
        return {'success': True, 'path': target.path, 'width': target.width, 'height': target.height,
                'format': 'png', 'data_base64': img_b64, 'size_bytes': len(img_bytes)}
    except Exception as e:
        try:
            target.save(SCREENSHOT_TEMP_PATH)
            with open(SCREENSHOT_TEMP_PATH, 'rb') as f:
                img_bytes = f.read()
            img_b64 = base64.b64encode(img_bytes).decode('ascii')
            return {'success': True, 'path': target.path, 'format': 'png',
                    'data_base64': img_b64, 'size_bytes': len(img_bytes), 'method': 'file_fallback'}
        except Exception as e2:
            return {'error': f'Screenshot failed: {str(e)} / fallback: {str(e2)}'}


def handle_chop_data(body):
    path = body.get('path')
    channel_names = body.get('channels', None)
    sample_range = body.get('range', None)
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    if not node.isCHOP:
        return {'error': f'Node is not a CHOP: {path}'}
    result = {'path': path, 'numChans': node.numChans, 'numSamples': node.numSamples, 'rate': node.rate, 'channels': {}}
    for chan in node.chans():
        if channel_names and chan.name not in channel_names:
            continue
        samples = list(chan.vals)
        if sample_range:
            samples = samples[max(0, sample_range[0]):min(len(samples), sample_range[1])]
        if len(samples) > 1000:
            step = len(samples) // 1000
            samples = samples[::step]
            result['channels'][chan.name] = {'values': samples, 'downsampled': True, 'original_length': node.numSamples}
        else:
            result['channels'][chan.name] = {'values': samples, 'downsampled': False}
    return result


def handle_sop_data(body):
    path = body.get('path')
    include_points = body.get('include_points', True)
    include_prims = body.get('include_prims', False)
    limit = body.get('limit', 500)
    if not path:
        return {'error': 'Missing required field: path'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    if not node.isSOP:
        return {'error': f'Node is not a SOP: {path}'}
    result = {'path': path, 'numPoints': node.numPoints, 'numPrims': node.numPrims, 'numVertices': node.numVertices}
    if include_points:
        points = []
        for i, pt in enumerate(node.points()):
            if i >= limit:
                break
            points.append({'index': pt.index, 'x': pt.x, 'y': pt.y, 'z': pt.z})
        result['points'] = points
        result['points_truncated'] = node.numPoints > limit
    if include_prims:
        prims = []
        for i, prim in enumerate(node.prims()):
            if i >= limit:
                break
            prims.append({'index': prim.index, 'numVertices': prim.numVertices})
        result['prims'] = prims
        result['prims_truncated'] = node.numPrims > limit
    return result


def handle_cooking_info(body):
    path = body.get('path', '/')
    recurse = body.get('recurse', False)
    sort_by = body.get('sort_by', 'cookTime')
    limit = body.get('limit', 20)
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    results = []
    def collect_cook(n):
        try:
            results.append({'path': n.path, 'name': n.name, 'type': n.type,
                'cookTime': n.cookTime if hasattr(n, 'cookTime') else 0,
                'cpuCookTime': n.cpuCookTime if hasattr(n, 'cpuCookTime') else 0,
                'cookFrame': n.cookFrame if hasattr(n, 'cookFrame') else 0})
        except Exception:
            pass
        if recurse and n.isCOMP:
            for child in n.children:
                collect_cook(child)
    collect_cook(node)
    results.sort(key=lambda x: x.get(sort_by, 0), reverse=True)
    results = results[:limit]
    return {'path': path, 'fps': project.cookRate, 'realTime': project.realTime,
            'frame': absTime.frame, 'total_nodes': len(results), 'nodes': results}


def handle_search_nodes(body):
    query = body.get('query', '')
    search_path = body.get('path', '/')
    search_type = body.get('search_type', 'name')
    limit = body.get('limit', 50)
    if not query:
        return {'error': 'Missing required field: query'}
    root = op(search_path)
    if root is None:
        return {'error': f'Search root not found: {search_path}'}
    query_lower = query.lower()
    results = []
    def search_recursive(n):
        if len(results) >= limit:
            return
        match = False
        if search_type in ('name', 'all') and query_lower in n.name.lower():
            match = True
        if search_type in ('type', 'all') and query_lower in n.type.lower():
            match = True
        if search_type in ('family', 'all') and query_lower in n.family.lower():
            match = True
        if match:
            results.append(_serialize_op(n))
        if n.isCOMP:
            for child in n.children:
                search_recursive(child)
    search_recursive(root)
    return {'query': query, 'search_type': search_type, 'count': len(results), 'nodes': results}


def handle_list_families(body):
    path = body.get('path', '/')
    root = op(path)
    if root is None:
        return {'error': f'Node not found: {path}'}
    families = {}
    def collect_types(n):
        fam = n.family
        if fam not in families:
            families[fam] = set()
        families[fam].add(n.type)
        if n.isCOMP:
            for child in n.children:
                collect_types(child)
    collect_types(root)
    return {'families': {k: sorted(list(v)) for k, v in sorted(families.items())}}


def handle_python_help(body):
    target = body.get('target', '')
    if not target:
        return {'error': 'Missing required field: target (e.g. "td", "td.OP", "tdu")'}
    import io
    old_stdout = sys.stdout
    captured = io.StringIO()
    sys.stdout = captured
    try:
        help(eval(target))
    except Exception as e:
        sys.stdout = old_stdout
        return {'error': f'Help failed for "{target}": {str(e)}'}
    finally:
        sys.stdout = old_stdout
    help_text = captured.getvalue()
    if len(help_text) > 10000:
        help_text = help_text[:10000] + '\n\n... (truncated)'
    return {'target': target, 'help': help_text}


def handle_python_classes(body):
    try:
        import td
        classes = [name for name in dir(td) if not name.startswith('_')]
        return {'module': 'td', 'classes': classes, 'count': len(classes)}
    except Exception as e:
        return {'error': f'Failed to list classes: {str(e)}'}


def handle_timeline(body):
    return {
        'frame': absTime.frame, 'seconds': absTime.seconds,
        'playing': project.realTime, 'fps': project.cookRate,
        'start': project.cookRange[0] if hasattr(project, 'cookRange') else 1,
        'end': project.cookRange[1] if hasattr(project, 'cookRange') else 600,
    }


def handle_timeline_set(body):
    action = body.get('action')
    frame = body.get('frame', None)
    fps = body.get('fps', None)
    if action == 'play':
        project.realTime = True
        return {'success': True, 'playing': True}
    elif action == 'pause':
        project.realTime = False
        return {'success': True, 'playing': False}
    elif action == 'frame' and frame is not None:
        absTime.frame = frame
        return {'success': True, 'frame': absTime.frame}
    elif fps is not None:
        project.cookRate = fps
        return {'success': True, 'fps': project.cookRate}
    else:
        return {'error': 'Provide action (play/pause/frame) or fps'}


def handle_pulse_param(body):
    path = body.get('path')
    param_name = body.get('param')
    if not path or not param_name:
        return {'error': 'Missing required fields: path and param'}
    node = op(path)
    if node is None:
        return {'error': f'Node not found: {path}'}
    p = getattr(node.par, param_name, None)
    if p is None:
        return {'error': f'Parameter not found: {param_name} on {path}'}
    try:
        p.pulse()
        return {'success': True, 'path': path, 'param': param_name}
    except Exception as e:
        return {'error': f'Failed to pulse: {str(e)}'}
'''

# ═══════════════════════════════════════════════════════════════
# Info text
# ═══════════════════════════════════════════════════════════════

INFO_TEXT = """TouchDesigner MCP Server v1.0.0
================================
Status: ACTIVE
Port: {port}
Endpoints: 28

Test: http://localhost:{port}/api/health

Tools available:
  td_get_info, td_get_nodes, td_get_node_detail,
  td_get_params, td_set_params, td_create_node,
  td_delete_node, td_copy_node, td_rename_node,
  td_connect_nodes, td_disconnect, td_get_connections,
  td_get_content, td_set_content, td_exec_python,
  td_screenshot, td_chop_data, td_sop_data,
  td_cooking_info, td_search_nodes, td_get_errors,
  td_list_families, td_python_help, td_python_classes,
  td_timeline, td_timeline_set, td_pulse_param

MCP Server command (for Claude Desktop):
  uvx --from /path/to/touchdesigner-mcp touchdesigner-mcp
"""

# ═══════════════════════════════════════════════════════════════
# Builder — creates the component hierarchy in TD
# ═══════════════════════════════════════════════════════════════

def build_mcp_component():
    """Create the MCP WebServer component inside TouchDesigner."""

    parent_node = op(PARENT_PATH)
    if parent_node is None:
        print(f"[MCP Setup] ERROR: Parent path '{PARENT_PATH}' not found.")
        print(f"[MCP Setup] Make sure you have a project open with {PARENT_PATH}")
        return False

    # Check if already exists
    existing = op(f'{PARENT_PATH}/{COMP_NAME}')
    if existing is not None:
        print(f"[MCP Setup] Component already exists at {PARENT_PATH}/{COMP_NAME}")
        print(f"[MCP Setup] Delete it first if you want to recreate:")
        print(f"            op('{PARENT_PATH}/{COMP_NAME}').destroy()")
        return False

    print("[MCP Setup] Creating MCP Server component...")

    # 1. Create the Base COMP container
    mcp_comp = parent_node.create('baseCOMP', COMP_NAME)
    mcp_comp.nodeX = 400
    mcp_comp.nodeY = -200
    mcp_comp.comment = 'MCP Server for AI agents (port 9981)'
    print(f"  Created: {mcp_comp.path}")

    # 2. Create the WebServer DAT
    webserver = mcp_comp.create('webserverDAT', 'webserver')
    webserver.nodeX = 0
    webserver.nodeY = 0
    webserver.par.port = MCP_PORT
    webserver.par.active = True

    # Try to set Callbacks DAT reference (parameter name may vary by TD version)
    try:
        webserver.par.callbacks = 'callbacks'
    except:
        try:
            webserver.par.callbackdat = 'callbacks'
        except:
            print("  WARNING: Could not auto-set callbacks parameter.")
            print("           Manually set WebServer DAT > Callbacks DAT = 'callbacks'")
    print(f"  Created: {webserver.path} (port {MCP_PORT})")

    # 3. Create the Callbacks Text DAT
    callbacks_dat = mcp_comp.create('textDAT', 'callbacks')
    callbacks_dat.nodeX = 300
    callbacks_dat.nodeY = 0
    callbacks_dat.text = CALLBACKS_CODE
    callbacks_dat.viewer = True
    print(f"  Created: {callbacks_dat.path} ({len(CALLBACKS_CODE)} chars)")

    # 4. Create the Info Text DAT
    info_dat = mcp_comp.create('textDAT', 'info')
    info_dat.nodeX = 600
    info_dat.nodeY = 0
    info_dat.text = INFO_TEXT.format(port=MCP_PORT)
    info_dat.viewer = True
    print(f"  Created: {info_dat.path}")

    # 5. Final status
    print("")
    print("=" * 55)
    print("  MCP SERVER READY")
    print("=" * 55)
    print(f"  Component:  {mcp_comp.path}")
    print(f"  WebServer:  {webserver.path}")
    print(f"  Port:       {MCP_PORT}")
    print(f"  Callbacks:  {callbacks_dat.path}")
    print(f"  Endpoints:  28 API handlers")
    print("")
    print(f"  Test URL:   http://localhost:{MCP_PORT}/api/health")
    print("")
    print("  IMPORTANT: Verify the WebServer DAT's 'Callbacks DAT'")
    print("  parameter points to 'callbacks'. If not, set it manually.")
    print("=" * 55)

    return True


# ═══════════════════════════════════════════════════════════════
# Run it
# ═══════════════════════════════════════════════════════════════

build_mcp_component()
